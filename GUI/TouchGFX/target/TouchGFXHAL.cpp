/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * File Name          : TouchGFXHAL.cpp
  ******************************************************************************
  * This file is generated by TouchGFX Generator 4.19.1.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2022 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

#include <TouchGFXHAL.hpp>

/* USER CODE BEGIN TouchGFXHAL.cpp */

#include "stm32l4xx_hal.h"
#include <touchgfx/hal/OSWrappers.hpp>
#include "main.h"

/* USER CODE BEGIN Includes */
#include "../st7789h2/st7789h2.h"
#include <touchgfx/hal/GPIO.hpp>
#include <CortexMMCUInstrumentation.hpp>
#include <KeySampler.hpp>
#include "FreeRTOS.h"
#include "task.h"
/* USER CODE END Includes */

/* USER CODE BEGIN private defines */

/* USER CODE END private defines */

/* USER CODE BEGIN private variables */
volatile bool firstFrameReadyToDisplay = false;
static uint16_t* currFbBase = 0;
/* USER CODE END private variables */

/* USER CODE BEGIN private functions */

/* USER CODE END private functions */

/* USER CODE BEGIN extern C prototypes */
extern "C"
{
    typedef enum
    {
        IO_OK       = 0x00,
        IO_ERROR    = 0x01,
        IO_TIMEOUT  = 0x02,
        IO_ALREADY_INITIALIZED  = 0x03
    }
    IO_StatusTypeDef;
    /**
      * @brief  LCD status structure definition
      */
#define LCD_OK         ((uint8_t)0x00)
#define LCD_ERROR      ((uint8_t)0x01)
#define LCD_TIMEOUT    ((uint8_t)0x02)

    /* Virtual pin offset IOExpander1 */
#define IO1_PIN_OFFSET               0
    /* Pins definition IOExpander */
#define IO1_PIN_2                     (uint32_t)(0x00000004 << IO1_PIN_OFFSET)

    bool os_inited = false;

    extern uint8_t BSP_IO_Init(void);
    extern void BSP_IO_WritePin(uint32_t IO_Pin, uint8_t PinState);

    uint8_t BSP_LCD_InitEx(uint32_t orientation);
    void BSP_LCD_Reset(void);
    void __ST7789H2_SetDisplayWindow(uint16_t Xpos, uint16_t Ypos, uint16_t Width, uint16_t Height);
}
/* USER CODE END extern C prototypes */

using namespace touchgfx;

/* USER CODE BEGIN private class objects */
static CortexMMCUInstrumentation mcuInstr;
static KeySampler btnctrl;
/* USER CODE END private class objects */

//TouchGFXHAL::TouchGFXHAL(touchgfx::DMA_Interface& dma, touchgfx::LCD& display, touchgfx::TouchController& tc, uint16_t width, uint16_t height)
///* USER CODE BEGIN TouchGFXHAL Constructor */
//    : TouchGFXGeneratedHAL(dma, display, tc, width, height)
///* USER CODE END TouchGFXHAL Constructor */
//{
///* USER CODE BEGIN TouchGFXHAL Constructor Code */
//
///* USER CODE END TouchGFXHAL Constructor Code */
//}

void TouchGFXHAL::initialize()
{
    /* USER CODE BEGIN initialize step 1 */
    GPIO::init();
    if (BSP_LCD_InitEx(ST7789H2_ORIENTATION_LANDSCAPE))
    {
        assert(0 && "Failed to initialize the LCD HW");
    }
    /* USER CODE END initialize step 1 */

    // Calling parent implementation of initialize().
    //
    // To overwrite the generated implementation, omit call to parent function
    // and implemented needed functionality here.
    // Please note, HAL::initialize() must be called to initialize the framework.

    TouchGFXGeneratedHAL::initialize();

    /* USER CODE BEGIN initialize step 2 */
    lockDMAToFrontPorch(false);

    mcuInstr.init();
    setMCUInstrumentation(&mcuInstr);
    enableMCULoadCalculation(true);

    setButtonController(&btnctrl);

    os_inited = true;
    /* USER CODE END initialize step 2 */
}

uint16_t* TouchGFXHAL::getTFTFrameBuffer() const
{
    return currFbBase;
}

void TouchGFXHAL::setTFTFrameBuffer(uint16_t* adr)
{
    currFbBase = adr;
}

void TouchGFXHAL::configureInterrupts()
{
    NVIC_SetPriority(DMA2D_IRQn, 7);
}

void TouchGFXHAL::enableLCDControllerInterrupt()
{
}

void TouchGFXHAL::disableInterrupts()
{
    NVIC_DisableIRQ(DMA2D_IRQn);
}

void TouchGFXHAL::enableInterrupts()
{
    NVIC_EnableIRQ(DMA2D_IRQn);
}

// Full refresh
void TouchGFXHAL::flushFrameBuffer()
{
    Rect rect = Rect(0, 0, 240, 240);

    HAL::flushFrameBuffer();

    this->flushFrameBuffer(rect);
}

void  TouchGFXHAL::flushFrameBuffer(const Rect& rect)
{
    // Partial framebuffer might be supported for this platform only when Double
    // Buffering is enabled
    dma.flush();

    HAL::flushFrameBuffer(rect);

    /* Set Cursor */
    __ST7789H2_SetDisplayWindow(rect.x, rect.y, rect.width, rect.height);

    /* Prepare to write to LCD RAM */
    ST7789H2_WriteReg(ST7789H2_WRITE_RAM, (uint8_t*)NULL, 0);

    /* Read dummy data */
    LCD_IO_ReadData();

    this->copyFrameBufferBlockToLCD(rect);

}

void TouchGFXHAL::copyFrameBufferBlockToLCD(const Rect rect)
{
    __IO uint16_t* ptr;
    int16_t height;

    // Use default implementation (CPU copy!).
    // This can be accelerated using regular DMA hardware
    for (height = 0; height < rect.height ; height++)
    {
        ptr = getClientFrameBuffer() + rect.x + (height + rect.y)  * 240;
        LCD_IO_WriteMultipleData((uint16_t*)ptr, rect.width);
    }
}

bool TouchGFXHAL::blockCopy(void* RESTRICT          dest,
                            const void* RESTRICT    src,
                            uint32_t            numBytes)
{
    bool retval = true;

    // Use default implementation (CPU copy!).
    // This can be accelerated using regular DMA hardware
    retval    = HAL::blockCopy(dest, src, numBytes);

    return retval;
}

/* USER CODE BEGIN virtual overloaded methods */
bool TouchGFXHAL::beginFrame()
{
    return HAL::beginFrame();
}

void TouchGFXHAL::endFrame()
{
    HAL::endFrame();
    if (frameBufferUpdatedThisFrame)
    {
        if (!firstFrameReadyToDisplay)
        {
            firstFrameReadyToDisplay = true;

            /* Backlight control signal assertion */
            HAL_GPIO_WritePin(LCD_BL_CTRL_GPIO_Port, LCD_BL_CTRL_Pin, GPIO_PIN_SET);
        }
    }
}

/* USER CODE END virtual overloaded methods */

/* USER CODE BEGIN extern C functions */
// TODO : Remove this and use BSP/Components/st7789H2 API once fixed
extern "C" {

    portBASE_TYPE IdleTaskHook(void* p)
    {
        if ((int)p) //idle task sched out
        {
            touchgfx::HAL::getInstance()->setMCUActive(true);
        }
        else //idle task sched in
        {
            touchgfx::HAL::getInstance()->setMCUActive(false);
        }
        return pdTRUE;
    }

    void TouchGFX_TickHandler(uint8_t PinStatus)
    {
        if (os_inited)
        {
            if (PinStatus) /* Raising edge : entering Active Area */
            {
                HAL::getInstance()->vSync();
                OSWrappers::signalVSync();
                // Swap frame buffers immediately instead of waiting for the task to be scheduled in.
                // Note: task will also swap when it wakes up, but that operation is guarded and will not have
                // any effect if already swapped.
                HAL::getInstance()->swapFrameBuffers();
                GPIO::set(GPIO::VSYNC_FREQ);
            }
            else /* Falling edge : exiting active area */
            {
                GPIO::clear(GPIO::VSYNC_FREQ);
                HAL::getInstance()->frontPorchEntered();
            }
        }
    }

    __weak void __ST7789H2_SetDisplayWindow(uint16_t Xpos, uint16_t Ypos, uint16_t Width, uint16_t Height)
    {
        uint8_t   parameter[4];

        /* CASET: Comumn Addrses Set */
        parameter[0] = 0x00;
        parameter[1] = Xpos;
        parameter[2] = 0x00;
        parameter[3] = Xpos + Width - 1;
        ST7789H2_WriteReg(ST7789H2_CASET, parameter, 4);
        /* RASET: Row Addrses Set */
        parameter[0] = 0x00;
        parameter[1] = Ypos;
        parameter[2] = 0x00;
        parameter[3] = Ypos + Height - 1;
        ST7789H2_WriteReg(ST7789H2_RASET, parameter, 4);
    }

    /**
      * @brief  Initializes the LCD with a given orientation.
      * @param  orientation: LCD_ORIENTATION_PORTRAIT or LCD_ORIENTATION_LANDSCAPE
      * @retval LCD status
      */
    __weak uint8_t BSP_LCD_InitEx(uint32_t orientation)
    {
        /* Initialize the IO functionalities */
        if (BSP_IO_Init() == IO_ERROR)
        {
            return LCD_ERROR;
        }

        /* LCD Power On */
        HAL_GPIO_WritePin(LCD_DISP_GPIO_Port, LCD_DISP_Pin, GPIO_PIN_RESET);

        /* Reset the LCD */
        BSP_LCD_Reset();

        if (ST7789H2_ReadID() != ST7789H2_ID)
        {
            return LCD_ERROR;
        }

        /* LCD Init */
        ST7789H2_Init();

        ST7789H2_SetOrientation(orientation);

        /* Fill LCD frame memory with black pixels */
        for (int i = 0; i < 240; i++)
        {
            ST7789H2_DrawHLine(0x0, 0, 0, 240);
        }

        return LCD_OK;
    }

    /**
      * @brief  Reset the LCD.
      * @param  None
      * @retval LCD state
      */
    __weak void BSP_LCD_Reset(void)
    {
        /* Apply hardware reset according to procedure indicated in FRD154BP2901 documentation */
        BSP_IO_WritePin(IO1_PIN_2, GPIO_PIN_RESET);
        HAL_Delay(5);   /* Reset signal asserted during 5ms  */
        BSP_IO_WritePin(IO1_PIN_2, GPIO_PIN_SET);
        HAL_Delay(10);  /* Reset signal released during 10ms */
        BSP_IO_WritePin(IO1_PIN_2, GPIO_PIN_RESET);
        HAL_Delay(20);  /* Reset signal asserted during 20ms */
        BSP_IO_WritePin(IO1_PIN_2, GPIO_PIN_SET);
        HAL_Delay(10);  /* Reset signal released during 10ms */
    }
}
/* USER CODE END extern C functions */

/* USER CODE END TouchGFXHAL.cpp */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
