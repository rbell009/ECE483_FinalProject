/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * File Name          : STM32TouchController.cpp
  ******************************************************************************
  * This file is generated by TouchGFX Generator 4.19.1.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2022 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* USER CODE BEGIN STM32TouchController */
#include "stm32l4xx_hal.h"
#include <STM32TouchController.hpp>
#include "../ft6x06/ft6x06.h"
#include "../mfxstm32l152/mfxstm32l152.h"

extern "C"
{
#define TS_MAX_NB_TOUCH                 ((uint32_t) FT6206_MAX_DETECTABLE_TOUCH)
#define TS_SWAP_NONE                    ((uint8_t) 0x01)
#define TS_SWAP_X                       ((uint8_t) 0x02)
#define TS_SWAP_Y                       ((uint8_t) 0x04)
#define TS_SWAP_XY                      ((uint8_t) 0x08)

#define TS_ORIENTATION_PORTRAIT         ((uint8_t) 0)
#define TS_ORIENTATION_LANDSCAPE        ((uint8_t) 1)
#define TS_ORIENTATION_UNDEFINED        ((uint8_t) 2)

#define IO1_I2C_ADDRESS                  ((uint16_t) 0x84)
#define TS_I2C_ADDRESS                  ((uint16_t) 0x70)
#define TS_I2C_TIMEOUT_MAX              3000

    /* Virtual pin offset IOExpander1 */
#define IO1_PIN_OFFSET               0
    /* Pins definition IOExpander */
#define IO1_PIN_1                     (uint32_t)(0x00000002 << IO1_PIN_OFFSET)
#define IO1_PIN_ALL                   (uint32_t)(0x000301FF << IO1_PIN_OFFSET)

#define MFX_WAKEUP_GPIO_PORT              GPIOH                       /* GPIOH */
#define MFX_WAKEUP_GPIO_CLK_ENABLE()      __HAL_RCC_GPIOH_CLK_ENABLE()
#define MFX_WAKEUP_GPIO_CLK_DISABLE()     __HAL_RCC_GPIOH_CLK_DISABLE()
#define MFX_WAKEUP_PIN                    GPIO_PIN_6                  /* PH.06 */

    typedef enum
    {
        IO_OK       = 0x00,
        IO_ERROR    = 0x01,
        IO_TIMEOUT  = 0x02,
        IO_ALREADY_INITIALIZED  = 0x03
    }
    IO_StatusTypeDef;

    /*
    *  @brief TS_StateTypeDef
    *  Define TS State structure
    */
    typedef struct
    {
        uint8_t  touchDetected;                /*!< Total number of active touches detected at last scan */
        uint16_t touchX[TS_MAX_NB_TOUCH];      /*!< Touch X[0], X[1] coordinates on 12 bits */
        uint16_t touchY[TS_MAX_NB_TOUCH];      /*!< Touch Y[0], Y[1] coordinates on 12 bits */
    } TS_StateTypeDef;

    /**
     *  @brief TS_StatusTypeDef
     *  Define BSP_TS_xxx() functions possible return value,
     *  when status is returned by those functions.
     */
    typedef enum
    {
        TS_OK                = 0x00, /*!< Touch Ok */
        TS_ERROR             = 0x01, /*!< Touch Error */
        TS_TIMEOUT           = 0x02, /*!< Touch Timeout */
        TS_DEVICE_NOT_FOUND  = 0x03  /*!< Touchscreen device not found */
    } TS_StatusTypeDef;

    static uint8_t  tsOrientation = TS_SWAP_NONE;

    extern I2C_HandleTypeDef hi2c2;
    extern void MX_I2C2_Init(void);

    uint8_t BSP_TS_InitEx(uint16_t ts_SizeX, uint16_t ts_SizeY, uint8_t  orientation);
    uint8_t BSP_TS_GetState(TS_StateTypeDef* TS_State);
}

static bool bsp_ts_initialized = false;

void STM32TouchController::init()
{
    /**
     * Initialize touch controller and driver
     *
     */
    if (BSP_TS_InitEx(240, 240, TS_ORIENTATION_LANDSCAPE) == TS_OK)
    {
        bsp_ts_initialized = true;
    }

    assert(bsp_ts_initialized);
}

bool STM32TouchController::sampleTouch(int32_t& x, int32_t& y)
{
    /**
     * By default sampleTouch returns false,
     * return true if a touch has been detected, otherwise false.
     *
     * Coordinates are passed to the caller by reference by x and y.
     *
     * This function is called by the TouchGFX framework.
     * By default sampleTouch is called every tick, this can be adjusted by HAL::setTouchSampleRate(int8_t);
     *
     */
    if (bsp_ts_initialized)
    {
        TS_StateTypeDef state;
        BSP_TS_GetState(&state);
        if (state.touchDetected)
        {
            x = state.touchX[0];
            y = state.touchY[0];
            return true;
        }
    }
    return false;
}

extern "C"
{
    /**
      * @brief Discovery I2C2 error treatment function
      * @retval None
      */
    static void I2Cx_Error(void)
    {
        /* De-initialize the I2C communication BUS */
        HAL_I2C_DeInit(&hi2c2);

        /* Re- Initiaize the I2C communication BUS */
        MX_I2C2_Init();
    }

    static uint8_t I2Cx_isDeviceReady(uint16_t Addr, uint32_t trial)
    {
        HAL_StatusTypeDef status = HAL_OK;
        uint8_t value = 0x0;

        __disable_irq();

        status = HAL_I2C_IsDeviceReady(&hi2c2, Addr, trial, 50);

        __enable_irq();

        /* Check the communication status */
        if (status != HAL_OK)
        {
            /* Re-Initiaize the BUS */
            I2Cx_Error();
            HAL_Delay(200);
        }

        return value;
    }

    /**
      * @brief  Write a value in a register of the device through BUS.
      * @param  Addr: Device address on BUS Bus.
      * @param  Reg: The target register address to write
      * @param  RegSize: The target register size (can be 8BIT or 16BIT)
      * @param  Value: The target register value to be written
      * @retval None
      */
    static void I2Cx_WriteData(uint16_t Addr, uint16_t Reg, uint16_t RegSize, uint8_t Value)
    {
        HAL_StatusTypeDef status = HAL_OK;

        __disable_irq();

        status = HAL_I2C_Mem_Write(&hi2c2, Addr, (uint16_t)Reg, RegSize, &Value, 1, TS_I2C_TIMEOUT_MAX);

        __enable_irq();


        /* Check the communication status */
        if (status != HAL_OK)
        {
            /* Re-Initiaize the BUS */
            I2Cx_Error();
            HAL_Delay(200);
        }
    }

    /**
      * @brief  Write a value in a register of the device through BUS.
      * @param  Addr: Device address on BUS Bus.
      * @param  Reg: The target register address to write
      * @param  RegSize: The target register size (can be 8BIT or 16BIT)
      * @param  pBuffer: The target register value to be written
      * @param  Length: buffer size to be written
      * @retval None
      */
    static HAL_StatusTypeDef I2Cx_WriteBuffer(uint16_t Addr, uint16_t Reg, uint16_t RegSize, uint8_t* pBuffer, uint16_t Length)
    {
        HAL_StatusTypeDef status = HAL_OK;

        __disable_irq();

        status = HAL_I2C_Mem_Write(&hi2c2, Addr, (uint16_t)Reg, RegSize, pBuffer, Length, TS_I2C_TIMEOUT_MAX);

        __enable_irq();


        /* Check the communication status */
        if (status != HAL_OK)
        {
            /* Re-Initiaize the BUS */
            I2Cx_Error();
            HAL_Delay(200);
        }

        return status;
    }

    /**
      * @brief  Read a register of the device through BUS
      * @param  Addr: Device address on BUS
      * @param  Reg: The target register address to read
      * @param  RegSize: The target register size (can be 8BIT or 16BIT)
      * @retval read register value
      */
    static uint8_t I2Cx_ReadData(uint16_t Addr, uint16_t Reg, uint16_t RegSize)
    {
        HAL_StatusTypeDef status = HAL_OK;
        uint8_t value = 0x0;

        __disable_irq();

        status = HAL_I2C_Mem_Read(&hi2c2, Addr, Reg, RegSize, &value, 1, TS_I2C_TIMEOUT_MAX);

        __enable_irq();

        /* Check the communication status */
        if (status != HAL_OK)
        {
            /* Re-Initiaize the BUS */
            I2Cx_Error();
            HAL_Delay(200);
        }

        return value;
    }

    /**
      * @brief  Reads multiple data on the BUS.
      * @param  Addr: I2C Address
      * @param  Reg: Reg Address
      * @param  RegSize : The target register size (can be 8BIT or 16BIT)
      * @param  pBuffer: pointer to read data buffer
      * @param  Length: length of the data
      * @retval 0 if no problems to read multiple data
      */
    static HAL_StatusTypeDef I2Cx_ReadBuffer(uint16_t Addr, uint16_t Reg, uint16_t RegSize, uint8_t* pBuffer, uint16_t Length)
    {
        HAL_StatusTypeDef status = HAL_OK;

        __disable_irq();

        status = HAL_I2C_Mem_Read(&hi2c2, Addr, (uint16_t)Reg, RegSize, pBuffer, Length, TS_I2C_TIMEOUT_MAX);

        __enable_irq();

        /* Check the communication status */
        if (status != HAL_OK)
        {
            /* Re-Initiaize the BUS */
            I2Cx_Error();
            HAL_Delay(200);
        }

        return status;
    }

    /**
      * @brief  Reads multiple data.
      * @param  i2c_handler : I2C handler
      * @param  Addr: I2C address
      * @param  Reg: Reg address
      * @param  MemAddress: Memory address
      * @param  Buffer: Pointer to data buffer
      * @param  Length: Length of the data
      * @retval Number of read data
      */
    static HAL_StatusTypeDef I2Cx_ReadMultiple(I2C_HandleTypeDef* i2c_handler,
                                               uint8_t Addr,
                                               uint16_t Reg,
                                               uint16_t MemAddress,
                                               uint8_t* Buffer,
                                               uint16_t Length)
    {
        HAL_StatusTypeDef status = HAL_OK;

        status = HAL_I2C_Mem_Read(i2c_handler, Addr, (uint16_t)Reg, MemAddress, Buffer, Length, 1000);

        /* Check the communication status */
        if (status != HAL_OK)
        {
            /* Re-Initiaize the BUS */
            I2Cx_Error();
            HAL_Delay(200);
        }
        return status;
    }

    /**
      * @brief  Writes a value in a register of the device through BUS in using DMA mode.
      * @param  i2c_handler : I2C handler
      * @param  Addr: Device address on BUS Bus.
      * @param  Reg: The target register address to write
      * @param  MemAddress: Memory address
      * @param  Buffer: The target register value to be written
      * @param  Length: buffer size to be written
      * @retval HAL status
      */
    static HAL_StatusTypeDef I2Cx_WriteMultiple(I2C_HandleTypeDef* i2c_handler,
                                                uint8_t Addr,
                                                uint16_t Reg,
                                                uint16_t MemAddress,
                                                uint8_t* Buffer,
                                                uint16_t Length)
    {
        HAL_StatusTypeDef status = HAL_OK;

        status = HAL_I2C_Mem_Write(i2c_handler, Addr, (uint16_t)Reg, MemAddress, Buffer, Length, 1000);

        /* Check the communication status */
        if (status != HAL_OK)
        {
            /* Re-Initiaize the BUS */
            I2Cx_Error();
            HAL_Delay(200);
        }
        return status;
    }

    /**
      * @brief  Initializes and configures the IO functionalities and configures all
      *         necessary hardware resources (GPIOs, clocks..).
      * @note   BSP_IO_Init() is using HAL_Delay() function to ensure that stmpe811
      *         IO Expander is correctly reset. HAL_Delay() function provides accurate
      *         delay (in milliseconds) based on variable incremented in SysTick ISR.
      *         This implies that if BSP_IO_Init() is called from a peripheral ISR process,
      *         then the SysTick interrupt must have higher priority (numerically lower)
      *         than the peripheral interrupt. Otherwise the caller ISR process will be blocked.
      * @retval IO_OK: if all initializations are OK. Other value if error.
      */
    __weak uint8_t BSP_IO_Init(void)
    {
        uint8_t mfxstm32l152_id = 0;

        mfxstm32l152_WakeUp(IO1_I2C_ADDRESS);

        HAL_Delay(10);

        /* Read ID and verify the IO expander is ready */
        mfxstm32l152_id = mfxstm32l152_ReadID(IO1_I2C_ADDRESS);

        if ((mfxstm32l152_id != MFXSTM32L152_ID_1) && (mfxstm32l152_id != MFXSTM32L152_ID_2))
        {
            return IO_ERROR;
        }

        /* Initialize the MFX IO driver structure  */
        mfxstm32l152_Init(IO1_I2C_ADDRESS);
        mfxstm32l152_IO_Start(IO1_I2C_ADDRESS, IO1_PIN_ALL >> IO1_PIN_OFFSET);

        return IO_OK;
    }

    /**
      * @brief  Configures the IO pin(s) according to IO mode structure value.
      * @param  IO_Pin: Output pin to be set or reset.
      *          This parameter can be any combination of the IO pins.
      * @param  IO_Mode: IO pin mode to configure
      *          This parameter can be one of the following values:
      *            @arg  IO_MODE_INPUT
      *            @arg  IO_MODE_OUTPUT
      *            @arg  IO_MODE_IT_RISING_EDGE
      *            @arg  IO_MODE_IT_FALLING_EDGE
      *            @arg  IO_MODE_IT_LOW_LEVEL
      *            @arg  IO_MODE_IT_HIGH_LEVEL
      * @retval IO_OK: if all initializations are OK. Other value if error.
      */
    __weak uint8_t BSP_IO_ConfigPin(uint32_t IO_Pin, IO_ModeTypedef IO_Mode)
    {
        uint32_t io1_pin = 0;

        io1_pin = (IO_Pin & IO1_PIN_ALL) >> IO1_PIN_OFFSET;


        /* Configure the selected IO Expander 1 pin(s) mode */
        mfxstm32l152_IO_Config(IO1_I2C_ADDRESS, io1_pin, IO_Mode);

        return 0;
    }

    /**
      * @brief  Sets the selected pins state.
      * @param  IO_Pin: Selected pins to write.
      *          This parameter can be any combination of the IO pins.
      * @param  PinState: New pins state to write
      * @retval None
      */
    __weak void BSP_IO_WritePin(uint32_t IO_Pin, uint8_t PinState)
    {
        uint32_t io1_pin = 0;

        io1_pin = (IO_Pin & IO1_PIN_ALL) >> IO1_PIN_OFFSET;

        /* Sets the IO Expander 1 selected pins state */
        mfxstm32l152_IO_WritePin(IO1_I2C_ADDRESS, io1_pin, PinState);

    }

    /********************************* LINK MFX ***********************************/
    /**
      * @brief  Initializes MFX low level.
      * @retval None
      */
    __weak void MFX_IO_Init(void)
    {
        // Nothing to do, already done by MX_I2C2_Init()
        /* Wait for device ready */
        if (I2Cx_isDeviceReady(IO1_I2C_ADDRESS, 4) != HAL_OK)
        {
            /* Re-Initiaize the BUS */
            I2Cx_Error();
            HAL_Delay(200);
        }
    }

    /**
      * @brief  Deinitializes MFX low level.
      * @retval None
      */
    __weak void MFX_IO_DeInit(void)
    {
        // Not needed
    }

    /**
      * @brief  Configures MFX low level interrupt.
      * @retval None
      */
    __weak void MFX_IO_ITConfig(void)
    {
        // Not needed
    }

    /**
      * @brief  Configures MFX wke up  pin.
      * @retval None
      */
    __weak void MFX_IO_EnableWakeupPin(void)
    {
        GPIO_InitTypeDef  GPIO_InitStruct;

        /* Enable wakeup gpio clock */
        MFX_WAKEUP_GPIO_CLK_ENABLE();

        /* MFX wakeup pin configuration */
        GPIO_InitStruct.Pin   = MFX_WAKEUP_PIN;
        GPIO_InitStruct.Mode  = GPIO_MODE_OUTPUT_PP;
        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
        GPIO_InitStruct.Pull  = GPIO_NOPULL;
        HAL_GPIO_Init(MFX_WAKEUP_GPIO_PORT, &GPIO_InitStruct);
    }

    /**
      * @brief  Wakeup MFX.
      * @retval None
      */
    __weak void MFX_IO_Wakeup(void)
    {
        /* Set Wakeup pin to high to wakeup Idd measurement component from standby mode */
        HAL_GPIO_WritePin(MFX_WAKEUP_GPIO_PORT, MFX_WAKEUP_PIN, GPIO_PIN_SET);

        /* Wait */
        HAL_Delay(1);

        /* Set gpio pin basck to low */
        HAL_GPIO_WritePin(MFX_WAKEUP_GPIO_PORT, MFX_WAKEUP_PIN, GPIO_PIN_RESET);
    }

    /**
      * @brief  MFX writes single data.
      * @param  Addr: I2C address
      * @param  Reg: Register address
      * @param  Value: Data to be written
      * @retval None
      */
    __weak void MFX_IO_Write(uint16_t Addr, uint8_t Reg, uint8_t Value)
    {
        I2Cx_WriteData(Addr, Reg, I2C_MEMADD_SIZE_8BIT, Value);
    }

    /**
      * @brief  MFX reads single data.
      * @param  Addr: I2C address
      * @param  Reg: Register address
      * @retval Read data
      */
    __weak uint8_t MFX_IO_Read(uint16_t Addr, uint8_t Reg)
    {
        return I2Cx_ReadData(Addr, Reg, I2C_MEMADD_SIZE_8BIT);
    }

    /**
      * @brief  MFX reads multiple data.
      * @param  Addr: I2C address
      * @param  Reg: Register address
      * @param  Buffer: Pointer to data buffer
      * @param  Length: Length of the data
      * @retval Number of read data
      */
    __weak uint16_t MFX_IO_ReadMultiple(uint16_t Addr, uint8_t Reg, uint8_t* Buffer, uint16_t Length)
    {
        return I2Cx_ReadBuffer(Addr, (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT, Buffer, Length);
    }

    /**
      * @brief  MFX writes multiple data.
      * @param  Addr: I2C address
      * @param  Reg: Register address
      * @param  Buffer: Pointer to data buffer
      * @param  Length: Length of the data
      * @retval None
      */
    __weak void MFX_IO_WriteMultiple(uint16_t Addr, uint8_t Reg, uint8_t* Buffer, uint16_t Length)
    {
        I2Cx_WriteBuffer(Addr, (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT, Buffer, Length);
    }

    /**
      * @brief  MFX delay
      * @param  Delay: Delay in ms
      * @retval None
      */
    __weak void MFX_IO_Delay(uint32_t Delay)
    {
        HAL_Delay(Delay);
    }

    /************************** LINK TS (TouchScreen) *****************************/
    /**
      * @brief  Initializes and configures the touch screen functionalities and
      *         configures all necessary hardware resources (GPIOs, I2C, clocks..)
      *         with a given orientation
      * @param  ts_SizeX : Maximum X size of the TS area on LCD
      * @param  ts_SizeY : Maximum Y size of the TS area on LCD
      * @param  orientation : TS_ORIENTATION_LANDSCAPE or TS_ORIENTATION_PORTRAIT
      * @retval TS_OK if all initializations are OK. Other value if error.
      */
    __weak uint8_t BSP_TS_InitEx(uint16_t ts_SizeX, uint16_t ts_SizeY, uint8_t  orientation)
    {
        /* Note : TS_I2C_ADDRESS is un-initialized here, but is not used at all in init function */
        /* but the prototype of Init() is like that in template and should be respected       */

        /* Initialize the communication channel to sensor (I2C) if necessary */
        /* that is initialization is done only once after a power up         */
        ft6x06_Init(TS_I2C_ADDRESS);

        if (ft6x06_ReadID(TS_I2C_ADDRESS) != FT6x36_ID_VALUE)
        {
            return TS_DEVICE_NOT_FOUND;
        }

        /* Get LCD chosen orientation */
        if (orientation == TS_ORIENTATION_PORTRAIT)
        {
            tsOrientation = TS_SWAP_X | TS_SWAP_Y;
        }
        else
        {
            tsOrientation = TS_SWAP_XY | TS_SWAP_Y;
        }

        /* Software reset the TouchScreen */
        ft6x06_Reset(TS_I2C_ADDRESS);

        /* Calibrate, Configure and Start the TouchScreen driver */
        ft6x06_TS_Start(TS_I2C_ADDRESS);

        return TS_OK;
    }

    /**
      * @brief  Returns status and positions of the touch screen.
      * @param  TS_State: Pointer to touch screen current state structure
      * @retval TS_OK if all initializations are OK. Other value if error.
      */
    __weak uint8_t BSP_TS_GetState(TS_StateTypeDef* TS_State)
    {
        static uint32_t _x[TS_MAX_NB_TOUCH] = {0, 0};
        static uint32_t _y[TS_MAX_NB_TOUCH] = {0, 0};
        uint8_t ts_status = TS_OK;
        uint16_t tmp;
        uint16_t Raw_x[TS_MAX_NB_TOUCH];
        uint16_t Raw_y[TS_MAX_NB_TOUCH];
        uint16_t xDiff;
        uint16_t yDiff;
        uint32_t index;

        /* Check and update the number of touches active detected */
        TS_State->touchDetected = ft6x06_TS_DetectTouch(TS_I2C_ADDRESS);
        if (TS_State->touchDetected)
        {
            for (index = 0; index < TS_State->touchDetected; index++)
            {
                /* Get each touch coordinates */
                ft6x06_TS_GetXY(TS_I2C_ADDRESS, &(Raw_x[index]), &(Raw_y[index]));

                if (tsOrientation & TS_SWAP_XY)
                {
                    tmp = Raw_x[index];
                    Raw_x[index] = Raw_y[index];
                    Raw_y[index] = tmp;
                }

                if (tsOrientation & TS_SWAP_X)
                {
                    Raw_x[index] = FT_6206_MAX_WIDTH_HEIGHT - 1 - Raw_x[index];
                }

                if (tsOrientation & TS_SWAP_Y)
                {
                    Raw_y[index] = FT_6206_MAX_WIDTH_HEIGHT - 1 - Raw_y[index];
                }

                xDiff = Raw_x[index] > _x[index] ? (Raw_x[index] - _x[index]) : (_x[index] - Raw_x[index]);
                yDiff = Raw_y[index] > _y[index] ? (Raw_y[index] - _y[index]) : (_y[index] - Raw_y[index]);

                if ((xDiff + yDiff) > 5)
                {
                    _x[index] = Raw_x[index];
                    _y[index] = Raw_y[index];
                }


                TS_State->touchX[index] = _x[index];
                TS_State->touchY[index] = _y[index];

            } /* of for(index=0; index < TS_State->touchDetected; index++) */

        } /* end of if(TS_State->touchDetected != 0) */

        return (ts_status);
    }

    /**
      * @brief  Initializes Touchscreen low level.
      * @retval None
      */
    __weak void TS_IO_Init(void)
    {
        static uint8_t ts_io_init = 0;

        if (ts_io_init == 0)
        {
            BSP_IO_ConfigPin(IO1_PIN_1, IO_MODE_OUTPUT);

            BSP_IO_WritePin(IO1_PIN_1, GPIO_PIN_RESET);
            HAL_Delay(10);
            BSP_IO_WritePin(IO1_PIN_1, GPIO_PIN_SET);
            HAL_Delay(200);

            ts_io_init = 1;
        }
    }

    /**
      * @brief  Writes a single data.
      * @param  Addr: I2C address
      * @param  Reg: Reg address
      * @param  Value: Data to be written
      * @retval None
      */
    __weak void TS_IO_Write(uint8_t Addr, uint8_t Reg, uint8_t Value)
    {
        I2Cx_WriteMultiple(&hi2c2, Addr, (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT, (uint8_t*)&Value, 1);
    }

    /**
      * @brief  Reads a single data.
      * @param  Addr: I2C address
      * @param  Reg: Reg address
      * @retval Data to be read
      */
    __weak uint8_t TS_IO_Read(uint8_t Addr, uint8_t Reg)
    {
        return I2Cx_ReadData(Addr, Reg, I2C_MEMADD_SIZE_8BIT);
    }

    /**
      * @brief  Reads multiple data with I2C communication
      *         channel from TouchScreen.
      * @param  Addr: I2C address
      * @param  Reg: Register address
      * @param  Buffer: Pointer to data buffer
      * @param  Length: Length of the data
      * @retval Number of read data
      */
    __weak uint16_t TS_IO_ReadMultiple(uint8_t Addr, uint8_t Reg, uint8_t* Buffer, uint16_t Length)
    {
        return I2Cx_ReadMultiple(&hi2c2, Addr, (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT, Buffer, Length);
    }

    /**
      * @brief  Writes multiple data with I2C communication
      *         channel from MCU to TouchScreen.
      * @param  Addr: I2C address
      * @param  Reg: Register address
      * @param  Buffer: Pointer to data buffer
      * @param  Length: Length of the data
      * @retval None
      */
    __weak void TS_IO_WriteMultiple(uint8_t Addr, uint8_t Reg, uint8_t* Buffer, uint16_t Length)
    {
        I2Cx_WriteMultiple(&hi2c2, Addr, (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT, Buffer, Length);
    }

    /**
      * @brief  Delay function used in TouchScreen low level driver.
      * @param  Delay: Delay in ms
      * @retval None
      */
    __weak void TS_IO_Delay(uint32_t Delay)
    {
        HAL_Delay(Delay);
    }
}
/* USER CODE END STM32TouchController */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
